<!DOCTYPE html>
<html>
<head>
    <title>Web-Craft 2D</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Courier New', monospace; }
        canvas { display: block; image-rendering: pixelated; }
        #ui { position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.6); color: white; padding: 15px; border-radius: 8px; pointer-events: none; }
        .key { color: #00ffcc; font-weight: bold; }
    </style>
</head>
<body>
    <div id="ui">
        <b>WEB-CRAFT 2D</b><br>
        <span class="key">WASD / Arrows</span>: Move & Jump<br>
        <span class="key">Left Click</span>: Mine Block<br>
        <span class="key">Right Click</span>: Place Block<br>
        <span class="key">1, 2, 3</span>: Switch Blocks
    </div>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Game Constants
        const blockSize = 32;
        const gravity = 0.5;
        const jumpForce = -10;
        const moveSpeed = 4;

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // World Data
        let world = {};
        let selectedBlock = 1; // 1: Grass, 2: Dirt, 3: Stone
        const blockColors = { 1: '#55aa55', 2: '#8b5a2b', 3: '#777777' };

        // Player Data
        const player = {
            x: 100, y: 0,
            w: 24, h: 28,
            vx: 0, vy: 0,
            onGround: false
        };

        // Generate World
        for (let x = 0; x < canvas.width / blockSize; x++) {
            let surfaceY = Math.floor(canvas.height / 2 / blockSize) + Math.floor(Math.sin(x * 0.2) * 2);
            for (let y = surfaceY; y < canvas.height / blockSize; y++) {
                let type = (y === surfaceY) ? 1 : (y < surfaceY + 3 ? 2 : 3);
                world[`${x},${y}`] = type;
            }
        }

        // Input Handling
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.key === '1') selectedBlock = 1;
            if (e.key === '2') selectedBlock = 2;
            if (e.key === '3') selectedBlock = 3;
        });
        window.addEventListener('keyup', e => keys[e.code] = false);

        // Build/Mine Handling
        canvas.addEventListener('mousedown', e => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = Math.floor((e.clientX - rect.left) / blockSize);
            const mouseY = Math.floor((e.clientY - rect.top) / blockSize);
            
            if (e.button === 0) delete world[`${mouseX},${mouseY}`]; // Left click
            if (e.button === 2) world[`${mouseX},${mouseY}`] = selectedBlock; // Right click
        });
        canvas.oncontextmenu = (e) => e.preventDefault();

        function update() {
            // Horizontal Move
            player.vx = 0;
            if (keys['KeyA'] || keys['ArrowLeft']) player.vx = -moveSpeed;
            if (keys['KeyD'] || keys['ArrowRight']) player.vx = moveSpeed;

            // Jump
            if ((keys['KeyW'] || keys['Space'] || keys['ArrowUp']) && player.onGround) {
                player.vy = jumpForce;
                player.onGround = false;
            }

            // Gravity
            player.vy += gravity;
            player.x += player.vx;
            player.y += player.vy;

            // Simple Collision
            player.onGround = false;
            Object.keys(world).forEach(key => {
                let [bx, by] = key.split(',').map(Number);
                let bxPos = bx * blockSize;
                let byPos = by * blockSize;

                // Basic Box Collision
                if (player.x < bxPos + blockSize && player.x + player.w > bxPos &&
                    player.y < byPos + blockSize && player.y + player.h > byPos) {
                    
                    // Reset position to top of block
                    if (player.vy > 0 && player.y + player.h - player.vy <= byPos) {
                        player.y = byPos - player.h;
                        player.vy = 0;
                        player.onGround = true;
                    } else if (player.vy < 0) {
                        player.y = byPos + blockSize;
                        player.vy = 0;
                    } else {
                        player.x -= player.vx;
                    }
                }
            });

            draw();
            requestAnimationFrame(update);
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw World
            for (let key in world) {
                let [x, y] = key.split(',').map(Number);
                ctx.fillStyle = blockColors[world[key]];
                ctx.fillRect(x * blockSize, y * blockSize, blockSize - 1, blockSize - 1);
            }

            // Draw Player
            ctx.fillStyle = '#ffdbac';
            ctx.fillRect(player.x, player.y, player.w, player.h);
            ctx.fillStyle = '#0000ff'; // Shirt
            ctx.fillRect(player.x, player.y + 10, player.w, player.h - 10);
        }

        update();
    </script>
</body>
</html>
